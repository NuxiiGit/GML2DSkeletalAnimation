2D Skeletal Animation Documentation File - by Nuxii @TAT3XD

========================================================================================================================================================

 #1 - GETTING STARTED

========================================================================================================================================================

Loading Armatures:

You have the option of building your armature from Spine, DragonBones, or Spriter formats using the following functions for each respectively:

| Funct: sk_armature_build_spine(json, name)
| Args:
|     json - a string containing a json structure in the spine skeleton file format
|     name - the name to give to the armature
| 
| Funct: sk_armature_build_dragonbones(json, armature_name_or_id)
| Args:
|     json - a string containing a json structure in the dragonbones skeleton file format
|     armature_name_or_id - the name or id of the armature you want to load (as specified in the editor)
| 
| Funct: sk_armature_build_spriter(json, entity_name_or_id)
| Args:
|     json - a string containing a json structure in the spriter entity file format
|     entity_name_or_id - the name of the entity you want to load (as specified in the editor)
| 

Each of these functions will parse their respective json, and return a reference to the armature data structure if successful.
If the build was unsuccessful, the function will return "noone", so you should always confirm the armature exists before attempting to render it.

========================================================================================================================================================

Loading Texture Atlases:

To render your armatures, you need to supply a texture atlas so the renderer can look-up the UV coordinates of each attachment of your skeleton.
Similar to armatures, you have the option of building your texture atlases from Spine, DragonBones, or Spriter formats using the following functions:

| Funct: sk_atlas_build_libgdx(libgdx, sprite, subimg, scale)
| Args:
|     libgdx - a multi-line raw-text string in the libgdx atlas format, this is the export format of spine
|     sprite - the index of the sprite to use as a texture
|     subimg - the subimage index for the sprite
|     scale - a multiplier to scale each region by
| 
| Funct: sk_atlas_build_dragonbones(json, sprite, subimg, scale)
| Args:
|     json - a string containing a json structure in the dragonbones texture atlas file format
|     sprite - the index of the sprite to use as a texture
|     subimg - the subimage index for the sprite
|     scale - a multiplier to scale each region by
| 
| Funct: sk_atlas_build_spriter(json, sprite, subimg, scale)
| Args:
|     json - a string containing a json structure in the spriter texture atlas file format
|     sprite - the index of the sprite to use as a texture
|     subimg - the subimage index for the sprite
|     scale - a multiplier to scale each region by
| 

========================================================================================================================================================

 #2 - RENDERING YOUR ARMATURE

========================================================================================================================================================

Baking Your Skeleton Into a Vertex Buffer:

Vertex buffers are the primary way to store and render your skeletons. To get started, you should create a target vertex buffer using 
vertex_create_buffer(). Using this buffer, we can now bake our skeleton onto it:

| // bake the skeleton data onto the vertex buffer, returning the texture target in the process
| var texture = vertex_bake_armature(armature,atlas,vbuff);
| 
| // submit the vertex buffer with the skeleton texture
| vertex_submit(vbuff,pr_trianglelist,texture);
| 

This code will build the buffer and render it at the origin of your room. If you want to draw your skeleton at a different location, you will need to
transform the world matrix, then submit your buffer:

| // update the world matrix so the buffer is drawn at the position of the object
| var previous_matrix = matrix_get(matrix_world);
| matrix_set(matrix_world,matrix_build(x,y,0,0,0,image_angle,image_xscale,image_yscale,0));
| 
| // submit the vertex buffer at the x and y position of the object
| vertex_submit(vbuff,pr_trianglelist,texture);
| 
| // reset the world matrix
| matrix_set(matrix_world,previous_matrix);
| 

========================================================================================================================================================

 #3 - UPDATING YOUR ARMATURE

========================================================================================================================================================

Basic Update Structure:

This engine is very "hands-off"; you have to do all the updating manually. This gives you the most control over your animations, but can be overwhelming
at first. Here I will explain the basic structure you should use to update your armatures.

In the following code, a spine armature with a single bone has been created and stored in the variable "armature":

| armature = sk_armature_build_spine(@'
|     {
|         "bones": [
|             {
|                 "name": "bone",
|                 "length": 10,
|                 "rotation": -90
|             }
|         ]
|     }',"myArmature"
| );
| 

To update this armature, we need to direct ourselfs to the step event (or whereever you are updating your skeleton), and first set our armature to its
setup pose. To do this, we should call sk_armature_setToSetupPose(armature), which will iterate through all the bones and reset their applied state.
Next, we need to calculate the bones world transform by calling sk_armature_updateWorldTransform(armature).

Your step event should look like this:

| // set the armature to its setup pose
| sk_armature_setToSetupPose(armature);
| 
| // calculate the armatures world state
| sk_armature_updateWorldTransform(armature);
| 

That should be all the code required to view the setup pose of your armature. Calling sk_armature_draw_debug(armature,x,y,1,1,0,sk_debug_bones) in
the draw event will draw a basic version of your armature without its attachments, so you can check you're doing things right.

========================================================================================================================================================

Applying Animations:

To apply animations, you must first obtain the reference to the animation from the armature through the function sk_armature_find_animation, and then
use the corresponding sk_animation_apply function to apply the animation to your setup pose.

| // get the animation
| var animation = sk_armature_find_animation(armature,"anim_run");
| 
| // set the armature to its setup pose
| sk_armature_setToSetupPose(armature);
| 
| // check whether the animation exists
| if(sk_struct_exists(animation)){
|     // apply the animation
|     var t = current_time*0.1; // the timer
|     sk_animation_apply(animation,t,t,sk_mixPose_add,1,true);
| }
| 
| // calculate the armatures world state
| sk_armature_updateWorldTransform(armature);
| 

This segment of code will find the reference to the animation called "anim_run" from the armature, and will apply it to the armature before updating its
world transform.

NOTE: You can pre-obtain the animation in the create event and store them for later, this is purely as an example.

========================================================================================================================================================