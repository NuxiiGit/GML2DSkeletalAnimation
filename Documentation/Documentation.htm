<!DOCTYPE html>
<html>
	<head>
		<title>2DSkeletalAnimation Script Documentation</title>

		<meta charset="utf-8"/>
		
		<script type="text/javascript">
			// update the tag
            function js_find_tag(){
				var js_searchBar = document.getElementById("js_search");
				location.href = "#"+js_searchBar.value;
				js_searchBar.value = ""; // reset value
			}
			// create event listener for the search bar
			window.addEventListener("load",
				function(){
					document.getElementById("js_search").addEventListener("keypress",
						function(e){
							if(e.keyCode==13){
								js_find_tag();
							}
						}
					);
					// create custom tags
					document.createElement("documentation");
				}
			);
        </script>
		<style>
			body{
				background-color: #281927;
				font-family: Arial, serif;
				font-size: 14px;
				color: #ddd0dc;
			}
			p{
				margin-left: 5px;
			}
			a{
				font-weight: bold;
				text-decoration-line: none;
				color: #ff43a4;
			}
			/*(wip) GMS2's header banner*/
			.title::before {
				background-color: #1c111b;
				position:absolute;
				content: " ";
				left:0;
				right:0;
				top:0;
				bottom:0;
				width: calc(100vw - 30px); /*vw - Viewport width. Does not take account of the scrollbar's width. Just taking away an arbitrary value for now*/
				border-bottom: 100%;
				z-index: -10;
				display: block;
				border-radius: 10px 10px 0px 0px;
				margin: auto;
			}
			.title{
				position: relative;
    			width: 600px;

				background-color: #c44687;
				font-weight: bold;
				font-size: 25px;
				margin-bottom: 15px;
				padding-left: 10px;
				padding-bottom: 5px;
				padding-top: 5px;

				border-radius: 10px 10px 0px 0px;
			}
			.title::after {
				content: " ";
				position: absolute;
				width:100%;
				height:100%;
				display: block;

				background-color: #c44687;
				transform-origin: bottom left;
				top: 0;
			    left: 0;
			    z-index: -1;

				border-radius: 10px 10px 0px 0px;
			    -ms-transform: skew(30deg, 0deg) translateX(30px);
			    -webkit-transform: skew(30deg, 0deg) translateX(30px);
			    transform: skew(30deg, 0deg) translateX(30px);

			    
			    /*: calc(100vw - 30px); /*vw - Viewport width. Does not take account of the scrollbar's width. Just taking away an arbitrary value for now*/
			}
			/*
			.title{
				background-color: #c44687;
				font-weight: bold;
				font-size: 25px;
				margin-bottom: 20px;
				padding-left: 5px;
				padding-bottom: 2px;
			}*/
			
			.brief{
				font-weight: bold;
				font-style: italic;
				margin-left: 20px;
			}
			.subtitle{
				background-color: #1c111b;
				font-size: 17px;
				border-radius: 25px;
				padding: 7px 14px 7px 14px;
				margin-left: 5px;
				margin-top: 20px;
				margin-bottom: 10px;
				display: inline-flex;
			}
			.subtitle::after{
				content: ":";
			}
			.code{
				background-color: #1c111b;
				font-family: "Courier New", monospace;
				border-radius: 10px;
				padding: 7px 9px 7px 9px;
				margin-left: 55px;
				margin-right: 100px;
				display: block;
			}
			.returns::before{
				content: "Returns: ";
				font-weight: bold;
				margin-left: 20px;
			}
			.footer {
				background-color: #1c111b;
				position: fixed;
				padding: 1px 1px 1px 3px;
				bottom: 0px;
				width: 100%;
				height: 30px;
				z-index: 100;
			}
			input[id^="spoiler"]{
				display: none;
			}
			input[id^="spoiler"] + label:hover {
				background-color: #c44687;
			}
			input[id^="spoiler"] + label:before {
				/*00a0 (non-breaking space). 0020 (normal space) doesn't work*/
				content: "‚ñ∫\00a0\00a0";
				color: #c44687;
				font-size: 16px;
			}
			input[id^="spoiler"] + label {
				display: block;
				width: 90%;
				background-color: #392D3D;
				
				font-weight: bold;
				font-size: 18px;
				margin-bottom: 20px;
				margin-left: 30px;
				margin-right: 30px;
				padding-left: 12px;
				padding-bottom: 6px;
				padding-top: 6px;
				text-align: left;
				margin: 0 auto;
				border-radius: 8px;

			}
			input[id^="spoiler"] ~ .spoiler {
			  width: 85%;
			  height: 0;
			  overflow: hidden;
			  opacity: 0;
			  margin: 0px auto 0; 
			  padding: 10px;
			}
			input[id^="spoiler"]:checked + label + .spoiler {
			  height: auto;
			  opacity: 1;
			  padding-bottom: 40px;
			}
			
			table{
				width:70%; 
				margin-left:15%; 
				margin-right:15%;
				margin-top: 20px;
				margin-bottom: 20px;
			}
			table, td, th{
				border-collapse: collapse;
				border: 1px solid #c44687;
				text-align: left;
				color: #f1f1f1;
			}
			th{
				background-color: #c44687;
				text-align: center;
			}
			tr:nth-child(even){
				background-color: #392d3d;
			}
			tr:nth-child(odd){
				background-color: #2d2330;
			}
			input{
				background-color: #ddd0dc;
				color: #281927;
				border-style: none;
				z-index: 100;
			}
			button{
				background-color: #589d62;
				color: #281927;
				border-style: none;
				z-index: 100;
			}
		</style>
	</head>
	<body>
		<div class="footer">
			<a href="#ref_home" style="font-size: 20px; margin-left: 5px; margin-right: 10px;">üè†</a>
			<input type="text" id="js_search" placeholder="Search for a script name..." /><button type="submit" onclick="js_find_tag();">‚ñ∫</button>
		</div>
		<!--
			Documentation
		-->
		<documentation id="ref_home">
			<div class="title">Home üè†</div>
			<p><i>If you are lost and want to return to this page, press the home symbol at the bottom left hand of the screen. Alternatively, if you are looking for a specific script, please use the search box located adjacent to said home button.</i></p>
			<p>Thank you for downloading this package! This runtime includes a vast range of scripts for constructing, accessing, managing, and rendering your own skeletal animations at runtime. Included in these scripts are proceedures for automatically decoding atlas and armature files from your favourite skeletal animation software into structures for use with your game.</p>
			<img src="./Assets/jumbotron.gif" style="display: block; margin-left: auto; margin-right: auto; width: 30%;"/>
			<div class="subtitle">Building and Rendering Your Skeletons</div>
			<p>This section will help get you started by introducing you to the system and its components, as well as describing how to perform the basic loading and manipulation of your skeleton data:</p>
			<ul>
				<li><a href="#ref_overview">Overview</a></li>
				<li><a href="#ref_gettingStarted">Getting Started</a></li>
				<li><a href="#ref_updatingYourArmature">Updating Your Armature</a></li>
				<li><a href="#ref_bakingSkeleton2VB">Baking Skeleton Data</a></li>
				<li><a href="#ref_debugOverlay">Debug Overlay</a></li>
			</ul>
			<div class="subtitle">Advanced Use</div>
			<p>If you want to get more familiar with the nitty-gritty of system, or learn some useful techniques for manipulating your skeleton data at runtime, this is the place for you. This section will go over the more overwhelming and powerful aspects of the runtime to help you get the most out of your animations:</p>
			<ul>
				<li><a href="#ref_animationState">Animation State</a></li>
				<li><a href="#ref_proceduralAnimation">Procedural Animation</a></li>
				<li><a href="#ref_skeletalManipulation">Manipulating Skeleton Data</a></li>
				<li><a href="#ref_usefulTechniques">Useful Techniques</a></li>
			</ul>
			<div class="subtitle">Links</div>
			<p>If you're having trouble or want to keep up to date, please visit one of the following links:</p>
			<ul>
				<li><a target="_blank" href="https://twitter.com/TAT3XD">My Twitter</a></li>
				<li><a target="_blank" href="https://forum.yoyogames.com/index.php?threads/2d-skeletal-animation-physics-integration.44898/">GMC Forum Post</a></li>
				<li><a target="_blank" href="https://github.com/NuxiiGit/GML2DSkeletalAnimation">GitHub Project Repository</a></li>
			</ul>
		</documentation>
		<documentation id="ref_overview">
			<div class="title">Overview</div>
		</documentation>
		<documentation id="ref_gettingStarted">
			<div class="title">Getting Started</div>

			<input type="checkbox"  id="spoiler_loadingArmatures"/>
			<label for="spoiler_loadingArmatures">Loading Armatures</label>

			<div class="spoiler">
				<p>You have the option of building your armature from Spine, DragonBones, or Spriter formats using the following functions for each respectively:</p>
				<ul>
					<li><a href="#sk_armature_build_spine">sk_armature_build_spine</a></li>
					<li><a href="#sk_armature_build_dragonbones">sk_armature_build_dragonbones</a></li>
					<li><a href="#sk_armature_build_spriter">sk_armature_build_spriter</a></li>
				</ul>
				<p>Each of these functions will parse their respective json, and return a reference to the armature data structure if successful.
	If the build was unsuccessful, the function will return "noone", so you should always confirm the armature exists before attempting to render it.</p>
			</div>

			<input type="checkbox"  id="spoiler_loadingTextureAtlases"/>
			<label for="spoiler_loadingTextureAtlases">Loading Texture Atlases</label>

			<div class="spoiler">
				<p>To render your armatures, you need to supply a texture atlas so the renderer can look-up the UV coordinates of each attachment of your skeleton.
Similar to armatures, you have the option of building your texture atlases from Spine, DragonBones, or Spriter formats using the following functions:</p>
				<ul>
					<li><a href="#sk_atlas_build_libgdx">sk_atlas_build_libgdx</a></li>
					<li><a href="#sk_atlas_build_dragonbones">sk_atlas_build_dragonbones</a></li>
					<li><a href="#sk_atlas_build_spriter">sk_atlas_build_spriter</a></li>
				</ul>
			</div>
		</documentation>
		<documentation id="ref_updatingYourArmature">
			<div class="title">Updating Your Armature</div>
				<input type="checkbox"  id="spoiler_basicUpdateStructure"/>
				<label for="spoiler_basicUpdateStructure">Basic Update Structure</label>

				<div class="spoiler">
					<p>This engine is very "hands-off"; you have to do all the updating manually. This gives you the most control over your animations, but can be overwhelming
at first. Here I will explain the basic structure you should use to update your armatures.

In the following code, a spine armature with a single bone has been created and stored in the variable "armature":</p>
				<div class="code"><pre>
armature = sk_armature_build_spine(@'
    {
        "bones": [
            {
                "name": "bone",
                "length": 10,
                "rotation": -90
            }
        ]
    }',"myArmature"
 );</pre></div>
			 <p>To update this armature, we need to direct ourselfs to the step event (or whereever you are updating your skeleton), and first set our armature to its setup pose. To do this, we should call sk_armature_setToSetupPose(armature), which will iterate through all the bones and reset their applied state. Next, we need to calculate the bones world transform by calling sk_armature_updateWorldTransform(armature).

			 Your step event should look like this:</p>
			 <div class="code"><pre>
// set the armature to its setup pose
sk_armature_setToSetupPose(armature);

// calculate the armatures world state
sk_armature_updateWorldTransform(armature);</pre></div>

			<p>That should be all the code required to view the setup pose of your armature. Calling sk_armature_draw_debug(armature,x,y,1,1,0,sk_debug_bones) in
the draw event will draw a basic version of your armature without its attachments, so you can check you're doing things right.</p>
			</div>

			<input type="checkbox"  id="spoiler_applyingAnimations"/>
			<label for="spoiler_applyingAnimations">Applying Animations</label>

			<div class="spoiler">
				<p>To apply animations, you must first obtain the reference to the animation from the armature through the function sk_armature_find_animation, and then
use the corresponding sk_animation_apply function to apply the animation to your setup pose.</p>
				<div class="code"><pre>
// get the animation
var animation = sk_armature_find_animation(armature,"anim_run");

// set the armature to its setup pose
sk_armature_setToSetupPose(armature);

// check whether the animation exists
if(sk_struct_exists(animation)){
    // apply the animation
    var t = current_time*0.1; // the timer
    sk_animation_apply(animation,t,t,sk_mixPose_add,1,true);
}

// calculate the armatures world state
sk_armature_updateWorldTransform(armature);</pre></div>
				<p>This segment of code will find the reference to the animation called "anim_run" from the armature, and will apply it to the armature before updating its world transform.</p>

				<p><i><b>Note: </b>You can pre-obtain the animation in the create event and store them for later, this is purely as an example.</i></p>
			</div>
		</documentation>
		<documentation id="ref_bakingSkeleton2VB">
			<div class="title">Baking Skeleton Data</div>
			<div class="brief">Baking Your Skeleton Into a Vertex Buffer:</div>
			<p>Vertex buffers are the primary way to store and render your skeletons. To get started, you should create a target vertex buffer using 
vertex_create_buffer(). Using this buffer, we can now bake our skeleton onto it:</p>
			<div class="code"><pre>
// bake the skeleton data onto the vertex buffer, returning the texture target in the process
var texture = vertex_bake_armature(armature,atlas,vbuff);

// submit the vertex buffer with the skeleton texture
vertex_submit(vbuff,pr_trianglelist,texture);</pre></div>
			<p>This code will build the buffer and render it at the origin of your room. If you want to draw your skeleton at a different location, you will need to
transform the world matrix, then submit your buffer:</p>
<div class="code"><pre>
// update the world matrix so the buffer is drawn at the position of the object
var previous_matrix = matrix_get(matrix_world);
matrix_set(matrix_world,matrix_build(x,y,0,0,0,image_angle,image_xscale,image_yscale,0));

// submit the vertex buffer at the x and y position of the object
vertex_submit(vbuff,pr_trianglelist,texture);

// reset the world matrix
matrix_set(matrix_world,previous_matrix);</pre></div>
		</documentation>
		<documentation id="ref_debugOverlay">
			<div class="title">Debug Overlay</div>
			<p>When you have finished building your Armature/Atlas for the first time, you may need to check whether all the data was loaded correctly. That's where the following scripts relating to debugging come in handy:</p>
			<ul>
				<li><a href="#sk_armature_draw_debug">sk_armature_draw_debug</a></li>
				<li><a href="#sk_atlas_draw_debug">sk_atlas_draw_debug</a></li>
				<li><a href="#sk_bone_draw_debug">sk_bone_draw_debug</a></li>
			</ul>
			<p>Additionally, these functions are particularly useful in the case of modding, since you can supply these debug views to the community so they know what they've done is correct.</p>
		</documentation>
		<documentation id="ref_animationTypes">
			<div class="title">Animation Types</div>
			<p>The following are the available animations within the runtime:</p>
			<ul>
				<li><a href="#ref_simpleAnimation">Simple Animation</a></li>
				<li><a href="#ref_animationState">Animation State</a></li>
				<li><a href="#ref_proceduralAnimation">Procedural Animation</a></li>
			</ul>
		</documentation>
		<documentation id="ref_simpleAnimation">
			<div class="title">Simple Animation</div>
			<p>With simple animations, you will be able to play a single animation on your armature.</p>
			<p>If you wish for your animations to interpolate between different animations, use <a href="#ref_animationState">Animation State</a>.</p>
			<p><i><b>Note: </b>Animations must be destroyed when no longer needed to prevent memory leaks.</i></p>
			<p>The following scripts exist for dealing with animations:</p>
			<ul>
				<li><a href="#sk_animation_create">sk_animation_create</a></li>
				<li><a href="#sk_animation_destroy">sk_animation_destroy</a></li>
				<li><a href="#sk_animation_get_duration">sk_animation_get_duration</a></li>
				<li><a href="#sk_animation_get_looping">sk_animation_get_looping</a></li>
				<li><a href="#sk_animation_set_duration">sk_animation_set_duration</a></li>
				<li><a href="#sk_animation_set_looping">sk_animation_set_looping</a></li>
				<li><a href="#sk_animation_add_timeline">sk_animation_add_timeline</a></li>
				<li><a href="#sk_animation_apply">sk_animation_apply</a></li>
			</ul>
			<p><i><b>Note: </b>If you want to use an existing animation on your armature, use <a href="#sk_armature_find_animation">sk_armature_find_animation</a></i>.</p>
		</documentation>
		<documentation id="ref_animationState">
			<div class="title">Animation State</div>
			<p>Animation states allows animations to interpolate between each other.</p>
			<p><i><b>Note: </b>Animation states must be destroyed when no longer needed to prevent memory leaks.</i></p>
			<p>The following scripts exist for dealing with animation states:</p>
			<ul>
				<li><a href="#sk_animationState_create">sk_animationState_create</a></li>
				<li><a href="#sk_animationState_destroy">sk_animationState_destroy</a></li>
				<li><a href="#sk_animationState_get_animation_mix">sk_animationState_get_animation_mix</a></li>
				<li><a href="#sk_animationState_get_default_mix">sk_animationState_get_default_mix</a></li>
				<li><a href="#sk_animationState_get_timescale">sk_animationState_get_timescale</a></li>
				<li><a href="#sk_animationState_set_animation_mix">sk_animationState_set_animation_mix</a></li>
				<li><a href="#sk_animationState_set_default_mix">sk_animationState_set_default_mix</a></li>
				<li><a href="#sk_animationState_set_timescale">sk_animationState_set_timescale</a></li>

				<li><a href="#sk_animationState_draw_debug">sk_animationState_draw_debug</a></li>
				<li><a href="#sk_animationState_current_animation">sk_animationState_current_animation</a></li>
				<li><a href="#sk_animationState_play_animation">sk_animationState_play_animation</a></li>
				<li><a href="#sk_animationState_update">sk_animationState_update</a></li>
				<li><a href="#sk_animationState_apply">sk_animationState_apply</a></li>
				<li><a href="#sk_animationState_add_animation">sk_animationState_add_animation</a></li>
				<li><a href="#sk_animationState_add_armature">sk_animationState_add_armature</a></li>
				<li><a href="#sk_animationState_find_animation">sk_animationState_find_animation</a></li>
			</ul>
		</documentation>
		<documentation id="ref_proceduralAnimation">
			<div class="title">Procedural Animation</div>
		</documentation>
		<documentation id="ref_skeletalManipulation">
			<div class="title">Manipulating Skeleton Data</div>
		</documentation>
		<documentation id="ref_usefulTechniques">
			<div class="title">Useful Techniques</div>
		</documentation>
		<!--
			Scripts
		-->
		<documentation id="sk_animation_create">
			<div class="title">sk_animation_create</div>
			<div class="brief">Creates a new structure and returns its reference</div>
			<div class="subtitle">Syntax</div>
			<div class="code">sk_animation_create(name);</div>
			<table>
				<tr>
					<th>Argument</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>name</td>
					<td>The name of the structure <i>(this is used to identify the structure in the future).</i></td>
				</tr>
			</table>
			<div class="returns">Animation Struct</div>
			<div class="subtitle">Description</div>
			<p>This script is used to initialize a simple animation. </p>
			<p>If you wish to load an animation from an existing armature, use <a href="#sk_armature_find_animation">sk_armature_find_animation</a>.</p>
			<div class="subtitle">Example</div>
			<div class="code"><pre>
var my_animation = sk_animation_create("anim_walk");</pre></div>
			<p>The example code will initialize a simple animation, and store the struct in my_animation.</p>
		</documentation>

		<documentation id="sk_animation_destroy">
			<div class="title">sk_animation_destroy</div>
			<div class="brief">Deletes the supplied structure and unhooks its array</div>
			<div class="subtitle">Syntax</div>
			<div class="code">sk_animation_destroy(event);</div>
			
			<table>
				<tr>
					<th>Argument</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>event</td>
					<td>The animation (struct) you wish to destroy</td>
				</tr>
			</table>

			<div class="returns">N/A</div>
			<div class="subtitle">Description</div>
			<p>You call this script whenever the animation is no longer needed.</p>
			<p>This can be written where the instance gets destroyed or when changing rooms.</p>
			<div class="subtitle">Example</div>
			<div class="code"><pre>
var my_animation = sk_animation_create("anim_walk");
sk_animation_destroy(my_animation);</pre></div>
		<p>The example code will initialize an animation called "my_animation" and immediately deletes "my_animation"</p>
		</documentation>

		<documentation id="sk_bone_create">
			<div class="title">sk_bone_create</div>
			<div class="brief">Creates a new bone structure and returns its reference.</div>
			<div class="subtitle">Syntax</div>
			<div class="code">sk_bone_create(name);</div>
			<table>
				<tr>
					<th>Argument</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>name</td>
					<td>The name of the structure.</td>
				</tr>
			</table>
			<div class="returns">Bone</div>
			<div class="subtitle">Description</div>
			<p>This script can be used to create a new bone at runtime; these can be added to an armature using <a href="#sk_armature_add_bone">sk_armature_add_bone</a>.</p>
			<div class="subtitle">Example</div>
			<div class="code"><pre>
var my_bone = bone_create("b_arm");
sk_bone_set_position(my_bone,10,20);</pre></div>
			<p>The example code creates a new bone called "b_arm", and stores it in the variable "my_bone". It's local position is then set to (10,20).</p>
		</documentation>
		
		<documentation id="sk_armature_build_spine">
			<div class="title">sk_armature_build_spine</div>
			<div class="brief">Parses the supplied json, and returns a reference to the armature data structure if it was successful.</div>
			<div class="subtitle">Syntax</div>
			<div class="code"><pre>
sk_armature_build_spine(json, name)</pre></div>
			<table>
				<tr>
					<th>Argument</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>json</td>
					<td>A string containing a json structure in the spine skeleton file format.</td>
				</tr>
				<tr>
					<td>name</td>
					<td>The name to give to the armature (it could be anything).</td>
				</tr>
			</table>
			<div class="returns">Armature Struct</div>
			<div class="subtitle">Description</div>
			<p>This script will parse the supplied json, and returns a reference to the armature data structure if it was successful.
If the build was unsuccessful, the function will return "noone", so you should always confirm the armature exists before attempting to render it.</p>
<p><i><b>Note: </b>The name of the armature has no significant value. It's purely cosmetic.</i></p>
			<div class="subtitle">Example</div>
			<div class="code"><pre>
var PATH_SPINEBOY = "Skeletons/Spine/Esoteric/Spineboy/spineboy-ess.json";
var file = file_text_open_read(PATH_SPINEBOY);
var raw = "";
do {
    raw += file_text_read_string(file)+"\n";
    file_text_readln(file);
} until(file_text_eof(file));
file_text_close(file);

armature_spineboy = sk_armature_build_spine(raw, "");</pre></div>
			<p>The example code will store the path to the armature in "PATH_SPINEBOY", and the file contents is converted into a string. After that, the string is passed into sk_armature_build_spine, and an empty name for the armature is supplied.</p>
		</documentation>
		<documentation id="sk_armature_build_dragonbones">
			<div class="title">sk_armature_build_dragonbones</div>
			<div class="brief">Parses the supplied json, and returns a reference to the armature data structure if it was successful.</div>
			<div class="subtitle">Syntax</div>
			<div class="code"><pre>
sk_armature_build_dragonbones(json, armature_name_or_id)</pre></div>
			<table>
				<tr>
					<th>Argument</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>json</td>
					<td>A string containing a json structure in the dragonbones skeleton file format.</td>
				</tr>
				<tr>
					<td>armature_name_or_id</td>
					<td>The name or id of the armature you want to load (as specified in the editor).</td>
				</tr>
			</table>
			<div class="returns">Armature Struct</div>
			<div class="subtitle">Description</div>
			<p>This script will parse the supplied json, and returns a reference to the armature data structure if it was successful.
If the build was unsuccessful, the function will return "noone", so you should always confirm the armature exists before attempting to render it.</p>
			<div class="subtitle">Example</div>
			<div class="code"><pre>
var PATH_DRAGON = "Skeletons/DragonBones/Egret/Dragon/Dragon_ske.json";
var file = file_text_open_read(PATH_DRAGON);
var raw = "";
do {
    raw += file_text_read_string(file)+"\n";
    file_text_readln(file);
} until(file_text_eof(file));
file_text_close(file);

armature_dragon = sk_armature_build_dragonbones(raw, "0");</pre></div>
			<p>The example code will store the path to the armature in "PATH_DRAGON", and the file contents is converted into a string. After that, the string is passed into sk_armature_build_dragonbones, using armature "0" that's defined in the editor.</p>
		</documentation>
		<documentation id="sk_armature_build_spriter">
			<div class="title">sk_armature_build_spriter</div>
			<div class="brief">Parses the supplied json, and returns a reference to the armature data structure if it was successful.</div>
			<div class="subtitle">Syntax</div>
			<div class="code"><pre>
sk_armature_build_spriter(json, armature_name_or_id)</pre></div>
			<table>
				<tr>
					<th>Argument</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>json</td>
					<td>A string containing a json structure in the spriter skeleton file format.</td>
				</tr>
				<tr>
					<td>armature_name_or_id</td>
					<td>The name or id of the armature you want to load (as specified in the editor).</td>
				</tr>
			</table>
			<div class="returns">Armature Struct</div>
			<div class="subtitle">Description</div>
			<p>This script will parse the supplied json, and returns a reference to the armature data structure if it was successful.
If the build was unsuccessful, the function will return "noone", so you should always confirm the armature exists before attempting to render it.</p>
			<div class="subtitle">Example</div>
			<div class="code"><pre>
var PATH_SPRITER = "Skeletons/Spriter/BrashMonkey/Platformer/outJSONskel.scon";
var file = file_text_open_read(PATH_SPRITER);
var raw = "";
do {
    raw += file_text_read_string(file)+"\n";
    file_text_readln(file);
} until(file_text_eof(file));
file_text_close(file);

armature_platformer = sk_armature_build_spriter(raw, "0");</pre></div>
			<p>The example code will store the path to the armature in "PATH_SPRITER", and the file contents is converted into a string. After that, the string is passed into sk_armature_build_spriter, using armature "0" that's defined in the editor.</p>
		</documentation>
		<documentation id="sk_atlas_build_libgdx">
			<div class="title">sk_atlas_build_libgdx</div>
			<div class="brief">Constructs an atlas file to be used with your armatures.</div>
			<div class="subtitle">Syntax</div>
			<div class="code"><pre>
sk_atlas_build_libgdx(libgdx, sprite, subimg, scale)</pre></div>
			<table>
				<tr>
					<th>Argument</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>libgdx</td>
					<td>A multi-line raw-text string in the libgdx atlas format, this is the export format of spine.</td>
				</tr>
				<tr>
					<td>sprite</td>
					<td>The index of the sprite to use as a texture</td>
				</tr>
				<tr>
					<td>subimg</td>
					<td>The subimage index for the sprite</td>
				</tr>
				<tr>
					<td>scale</td>
					<td>A multiplier to scale each region by</td>
				</tr>
			</table>
			<div class="returns">Atlas Struct</div>
			<div class="subtitle">Description</div>
			<p>To render your armatures, you need to supply a texture atlas so the renderer can look-up the UV coordinates of each attachment of your skeleton.
Similar to armatures, you have the option of building your texture atlases from Spine.</p>
			<div class="subtitle">Example</div>
			<div class="code"><pre>
var PATH_SPINEBOY_SPRITE = "spineboy.png";
var PATH_SPINEBOY_ATLAS = "spineboy.atlas";
var sprite = sprite_add(PATH_SPINEBOY_SPRITE, 1, false, 0, 0);
var file = file_text_open_read(PATH_SPINEBOY_ATLAS);
var raw = "";
do {
    raw += file_text_read_string(file)+"\n";
    file_text_readln(file);
} until(file_text_eof(file));
file_text_close(file);

atlas_spineboy = sk_atlas_build_libgdx(raw, sprite, 0, 1);</pre></div>
			<p>The example code will store the path to the image in "PATH_SPINEBOY_SPRITE", the path to the atlas in "PATH_SPINEBOY_ATLAS", and the file contents of the atlas is converted into a string. After that, the string is passed into sk_atlas_build_libgdx.</p>
		</documentation>
		<documentation id="sk_atlas_build_dragonbones">
			<div class="title">sk_atlas_build_dragonbones</div>
			<div class="brief">Constructs an atlas file to be used with your armatures.</div>
			<div class="subtitle">Syntax</div>
			<div class="code"><pre>
sk_atlas_build_dragonbones(json, sprite, subimg, scale)</pre></div>
			<table>
				<tr>
					<th>Argument</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>json</td>
					<td>A string containing a json structure in the dragonbones texture atlas file format</td>
				</tr>
				<tr>
					<td>sprite</td>
					<td>The index of the sprite to use as a texture</td>
				</tr>
				<tr>
					<td>subimg</td>
					<td>The subimage index for the sprite</td>
				</tr>
				<tr>
					<td>scale</td>
					<td>A multiplier to scale each region by</td>
				</tr>
			</table>
			<div class="returns">Atlas Struct</div>
			<div class="subtitle">Description</div>
			<p>To render your armatures, you need to supply a texture atlas so the renderer can look-up the UV coordinates of each attachment of your skeleton.
Similar to armatures, you have the option of building your texture atlases from Dragonbones.</p>
			<div class="subtitle">Example</div>
			<div class="code"><pre>
var PATH_DRAGON_SPRITE = "Dragon_tex.png";
var PATH_DRAGON_ATLAS = "Dragon_tex.json";
var sprite = sprite_add(PATH_DRAGON_SPRITE, 1, false, 0, 0);
var file = file_text_open_read(PATH_DRAGON_ATLAS);
var raw = "";
do {
    raw += file_text_read_string(file)+"\n";
    file_text_readln(file);
} until(file_text_eof(file));
file_text_close(file);

atlas_dragon = sk_atlas_build_dragonbones(raw, sprite, 0, 1);</pre></div>
			<p>The example code will store the path to the image in "PATH_DRAGON_SPRITE", the path to the atlas in "PATH_DRAGON_ATLAS", and the file contents of the atlas is converted into a string. After that, the string is passed into sk_atlas_build_dragonbones.</p>
		</documentation>
		<documentation id="sk_atlas_build_spriter">
			<div class="title">sk_atlas_build_spriter</div>
			<div class="brief">Constructs an atlas file to be used with your armatures.</div>
			<div class="subtitle">Syntax</div>
			<div class="code"><pre>
sk_atlas_build_spriter(json, sprite, subimg, scale)</pre></div>
			<table>
				<tr>
					<th>Argument</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>json</td>
					<td>A string containing a json structure in the spriter texture atlas file format</td>
				</tr>
				<tr>
					<td>sprite</td>
					<td>The index of the sprite to use as a texture</td>
				</tr>
				<tr>
					<td>subimg</td>
					<td>The subimage index for the sprite</td>
				</tr>
				<tr>
					<td>scale</td>
					<td>A multiplier to scale each region by</td>
				</tr>
			</table>
			<div class="returns">Atlas Struct</div>
			<div class="subtitle">Description</div>
			<p>To render your armatures, you need to supply a texture atlas so the renderer can look-up the UV coordinates of each attachment of your skeleton.
Similar to armatures, you have the option of building your texture atlases from Spriter.</p>
			<div class="subtitle">Example</div>
			<div class="code"><pre>
var PATH_SPRITER_SPRITE = "outJSON.png";
var PATH_SPRITER_ATLAS = "outJSON.json";
var sprite = sprite_add(PATH_SPRITER_ATLAS, 1, false, 0, 0);
var file = file_text_open_read(PATH_SPRITER_ATLAS);
var raw = "";
do {
    raw += file_text_read_string(file)+"\n";
    file_text_readln(file);
} until(file_text_eof(file));
file_text_close(file);

atlas_platformer = sk_atlas_build_spriter(raw, sprite, 0, 1);</pre></div>
			<p>The example code will store the path to the image in "PATH_SPRITER_SPRITE", the path to the atlas in "PATH_SPRITER_ATLAS", and the file contents of the atlas is converted into a string. After that, the string is passed into sk_atlas_build_spriter.</p>
		</documentation>
		<br/><br/>
	</body>
</html>